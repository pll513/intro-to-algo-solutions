# 第一章 基础知识

### 练习
#### **1.1-1**
> 给出现实生活中需要排序的一个例子或者现实生活中需要计算凸壳的一个例子。

排序的例子：新生入学名单用学生的姓名按拼音字母排序。
凸壳的例子：农民伯伯种了几棵苹果树，现在想把它们用几段篱笆围起来，但是又想让使用的篱笆总长尽可能短。

_注：凸壳(Convex Hull)可能翻译成凸包更好_

#### **1.1-2**
> 除速度外，在真实环境中还可能使用哪些其他有关效率的量度？

准确性、占用更低的内存、可维护性、可拓展性、用户友好……

#### **1.1-3**
> 选择一种你以前已知的数据结构，并讨论其优势和局限。

数组：非常快的存储和随机访问；存储空间固定且插入和删除的开销很大。

#### **1.1-4**
> 前面给出的最短路径与旅行商问题有哪些相似之处？又有哪些不同？

相似：都是路径之和的最小值；都可以通过节点和边来建模。
不同：最短路径问题强制通过的点只有起点和终点，而旅行商问题必须通过所有给定点；最短路径的起点和终点一般不是同一个点，而旅行商问题的起点和终点是同一个点。

#### **1.1-5**
> 提供一个现实生活的问题，其中只有最佳解才行。然后提供一个问题，其中近似最佳的一个解也足够好。

事关人类存亡的算法应该最优解ヽ(･ω･｡)ﾉ 其他的就随意点好了。

#### **1.2-1**
> 给出在应用层需要算法内容的一个例子，并讨论涉及的算法的功能。

比如网上购物时，某宝的推荐系统，通过分析用户的搜索和购物记录给出推荐的商品。

#### **1.2-2**
> 假设我们正比较插入排序与归并排序在相同机器上的实现。对规模为$$n$$的输入，插入排序运行$$8n^2$$步，而归并排序运行$$64n\lg{n}$$步。问对哪些$$n$$值，插入排序优于归并排序？

由已知：
$$
\begin{equation}
8n^2 \lt 64n\lg{n}
\end{equation}
$$
即：
$$
\begin{equation}
\frac{n}{\lg{n}} \lt 8
\end{equation}
$$
又：
$$
\begin{equation}
\frac{43}{\lg{43}} \approx 7.79 \lt 8 \\
\frac{44}{\lg{44}} \approx 8.06 \gt 8
\end{equation}
$$

所以满足插入排序优于归并排序的$$n$$不大于43。

#### **1.2-3**
> $$n$$的最小值为何值时，运行时间为$$100n^2$$的一个算法在相同机器上快于运行时间为$$2^n$$的另一个算法？

由已知：
$$
\begin{equation}
100n^2 \lt 2^n
\end{equation}
$$
即：
$$
\begin{equation}
\frac{100n^2}{2^n} \lt 1
\end{equation}
$$
又：
$$
\begin{equation}
\frac{100 \cdot (14)^2}{2^{14}} \approx 1.20 \gt 1 \\
\frac{100 \cdot (15)^2}{2^{15}} \approx 0.69 \lt 1
\end{equation}
$$

所以$$n$$的最小值为15。

### 思考题
#### **1-1**
> _（运行时间比较）_假设求解问题的算法需要$$f(n)$$毫秒，对下表中的每个函数$$f(n)$$和时间$$t$$，确定可以在时间$$t$$内求解的问题的最大规模$$n$$。

|  | 1秒钟  | 1分钟 | 1小时 | 1天 | 1月 | 1年 | 1世纪 |
|:-------------: |:---------------:|:---------------:|:---------------:|:---------------:|:---------------:|:---------------:|:---------------:|
| $$\lg{n}$$ | some wordy text |         $1600 |
| $$\sqrt{n}$$      | centered        |           $12 |
| $$n$$ | are neat        |            $1 |
| $$n\lg{n}$$ | are neat        |            $1 
| $$n^2$$ | are neat        |            $1 |
| $$n^3$$ | are neat        |            $1 |
| $$2^n$$ | are neat        |            $1 |
| $$n!$$ | are neat        |            $1 |






































































